// Generated by CoffeeScript 1.4.0
(function() {
  var Analyzer, AptanaSch, CSharpParser, CodePainter, CodeReader, CoffeeScriptParser, CppCommentAnalyzer, CppCommentPlusAnalyzer, DelimiterAnalyzer, Factory, JavaParser, NewLineAnalyzer, PaddingAnalyzer, Painter, PainterFactory, PainterFactoryController, PaintersBase, ParserFactory, RubyParser, Scheme, SchemeDescription, SchemeFactory, SchemeFactoryController, ServicePainterBorder, SharpDirectiveAnalyzer, SnipController, SpaceAnalyzer, StringAnalyzer, SyntaxParser, SyntaxToken, TokenComment, TokenDelimiter, TokenKeyword, TokenNewLine, TokenNormal, TokenOutlined, TokenPadding, TokenSharpDirective, TokenSpace, TokenString, TokenUndefined, UnixCommentAnalyzer, VisualStudioTenSch, autoLoader, root, _base, _base1, _base2, _base3, _base4, _ref, _ref1, _ref2, _ref3, _ref4,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if ((_ref = (_base = Array.prototype).some) == null) {
    _base.some = function(f) {
      var x, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          return true;
        }
      }
      return false;
    };
  }

  if ((_ref1 = (_base1 = Array.prototype).every) == null) {
    _base1.every = function(f) {
      var x, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (!f(x)) {
          return false;
        }
      }
      return true;
    };
  }

  if ((_ref2 = (_base2 = String.prototype).toImg) == null) {
    _base2.toImg = function() {
      var img;
      img = document.createElement("img");
      img.src = this;
      return img;
    };
  }

  if ((_ref3 = (_base3 = String.prototype).trim) == null) {
    _base3.trim = function() {
      return this.replace(/^\s+|\s+$/g, '');
    };
  }

  if ((_ref4 = (_base4 = String.prototype).dashToCamel) == null) {
    _base4.dashToCamel = function() {
      return this.replace(/\W+(.)/g, function(x, chr) {
        return chr.toUpperCase();
      });
    };
  }

  Analyzer = (function() {

    function Analyzer() {}

    Analyzer.prototype.match = function(reader, temporaryToken, tokens) {
      return false;
    };

    Analyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      flush(temporaryToken);
      temporaryToken = null;
      flush(new TokenUndefined());
      return temporaryToken;
    };

    return Analyzer;

  })();

  CppCommentAnalyzer = (function(_super) {

    __extends(CppCommentAnalyzer, _super);

    function CppCommentAnalyzer() {
      return CppCommentAnalyzer.__super__.constructor.apply(this, arguments);
    }

    CppCommentAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      return temporaryToken === null && reader.current() === '/' && reader.fetchNext() === '/';
    };

    CppCommentAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      reader.readUntilCharsLast(false, "\r", "\n");
      flush(new TokenComment("/" + reader.buffer));
      return temporaryToken;
    };

    return CppCommentAnalyzer;

  })(Analyzer);

  CppCommentPlusAnalyzer = (function(_super) {

    __extends(CppCommentPlusAnalyzer, _super);

    function CppCommentPlusAnalyzer() {
      return CppCommentPlusAnalyzer.__super__.constructor.apply(this, arguments);
    }

    CppCommentPlusAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      return temporaryToken === null && reader.current() === '/' && reader.fetchNext() === '*';
    };

    CppCommentPlusAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      reader.readUntil((function(x) {
        return x.current() === '*' && x.fetchNext() === '/';
      }));
      flush(new TokenComment("/" + reader.buffer + "/"));
      return temporaryToken;
    };

    return CppCommentPlusAnalyzer;

  })(Analyzer);

  DelimiterAnalyzer = (function(_super) {

    __extends(DelimiterAnalyzer, _super);

    function DelimiterAnalyzer(delimeters) {
      this.delimeters = delimeters != null ? delimeters : null;
      if (this.delimeters === null) {
        this.delimeters = ['{', '}', '[', ']', '=', ';', ':', '?', '(', ')', ',', '<', '>', '.'];
      }
    }

    DelimiterAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      var c;
      c = reader.current();
      return this.delimeters.some(function(x) {
        return c === x;
      });
    };

    DelimiterAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      flush(temporaryToken);
      temporaryToken = null;
      flush(new TokenDelimiter(reader.current()));
      return temporaryToken;
    };

    return DelimiterAnalyzer;

  })(Analyzer);

  NewLineAnalyzer = (function(_super) {

    __extends(NewLineAnalyzer, _super);

    function NewLineAnalyzer() {
      return NewLineAnalyzer.__super__.constructor.apply(this, arguments);
    }

    NewLineAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      var ch;
      ch = reader.current();
      return ch === "\r" || ch === "\n";
    };

    NewLineAnalyzer.prototype.opposite = function(c) {
      var _ref5;
      return (_ref5 = c === "\r") != null ? _ref5 : {
        "\n": "\r"
      };
    };

    NewLineAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      flush(temporaryToken);
      temporaryToken = null;
      flush(new TokenNewLine());
      if (reader.fetchNext() === this.opposite(reader.current())) {
        reader.skip(1);
      }
      return temporaryToken;
    };

    return NewLineAnalyzer;

  })(Analyzer);

  PaddingAnalyzer = (function(_super) {

    __extends(PaddingAnalyzer, _super);

    function PaddingAnalyzer() {
      return PaddingAnalyzer.__super__.constructor.apply(this, arguments);
    }

    PaddingAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      return reader.current() === "\t";
    };

    PaddingAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      flush(temporaryToken);
      temporaryToken = null;
      flush(new TokenPadding());
      return temporaryToken;
    };

    return PaddingAnalyzer;

  })(Analyzer);

  SpaceAnalyzer = (function(_super) {

    __extends(SpaceAnalyzer, _super);

    function SpaceAnalyzer() {
      return SpaceAnalyzer.__super__.constructor.apply(this, arguments);
    }

    SpaceAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      return reader.current() === ' ';
    };

    SpaceAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      flush(temporaryToken);
      temporaryToken = null;
      flush(new TokenSpace());
      return temporaryToken;
    };

    return SpaceAnalyzer;

  })(Analyzer);

  StringAnalyzer = (function(_super) {

    __extends(StringAnalyzer, _super);

    function StringAnalyzer() {
      return StringAnalyzer.__super__.constructor.apply(this, arguments);
    }

    StringAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      var ch;
      ch = reader.current();
      return ch === '"' || ch === "'";
    };

    StringAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      var buff, ch;
      flush(temporaryToken);
      temporaryToken = null;
      ch = reader.current();
      buff = ch;
      while (true) {
        if (!reader.readUntilChars(ch)) {
          buff += reader.buffer;
          break;
        }
        buff += reader.buffer;
        if (buff.length === 2) {
          break;
        }
        if (buff.substring(buff.length - 2, buff.length - 1) === "\\" && buff.substring(buff.length - 3, buff.length - 2) !== "\\") {
          continue;
        }
        break;
      }
      flush(new TokenString(buff));
      return temporaryToken;
    };

    return StringAnalyzer;

  })(Analyzer);

  UnixCommentAnalyzer = (function(_super) {

    __extends(UnixCommentAnalyzer, _super);

    function UnixCommentAnalyzer() {
      return UnixCommentAnalyzer.__super__.constructor.apply(this, arguments);
    }

    UnixCommentAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      return temporaryToken === null && reader.current() === '#';
    };

    UnixCommentAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      reader.readUntilCharsLast(false, "\r", "\n");
      flush(new TokenComment("#" + reader.buffer));
      return temporaryToken;
    };

    return UnixCommentAnalyzer;

  })(Analyzer);

  CodeReader = (function() {

    function CodeReader(data) {
      this.data = data;
      this.index = 0;
      this.buffer = '';
    }

    CodeReader.prototype.current = function() {
      return this.data.substring(this.index, this.index + 1);
    };

    CodeReader.prototype.fetchPrev = function(offset) {
      if (offset == null) {
        offset = 0;
      }
      if (0 <= this.index - offset) {
        return this.data.substring(this.index - offset, this.index - offset + 1);
      }
      return null;
    };

    CodeReader.prototype.skip = function(offset) {
      var newIndex;
      newIndex = this.index + offset;
      if (newIndex >= 0 && newIndex < this.data.length) {
        return this.index = newIndex;
      }
    };

    CodeReader.prototype.fetchNext = function(offset) {
      if (offset == null) {
        offset = 0;
      }
      if (this.data.length > this.index + offset) {
        return this.data.substring(this.index + offset, this.index + offset + 1);
      }
      return null;
    };

    CodeReader.prototype.readNext = function() {
      if (this.index + 1 >= this.data.length) {
        return false;
      }
      this.index += 1;
      return true;
    };

    CodeReader.prototype.readUntil = function(condition, withLast) {
      if (withLast == null) {
        withLast = true;
      }
      this.buffer = '';
      while (this.readNext()) {
        if (condition(this)) {
          if (withLast) {
            this.buffer += this.current();
          } else {
            this.index--;
          }
          return true;
        } else {
          this.buffer += this.current();
        }
      }
      return this.buffer += this.current();
    };

    CodeReader.prototype.readUntilChars = function() {
      var args;
      args = Array.prototype.slice.call(arguments);
      return this.readUntil(function(x) {
        return args.some(function(v) {
          return x.current() === v;
        });
      });
    };

    CodeReader.prototype.readUntilCharsLast = function(withLast) {
      var args;
      args = Array.prototype.slice.call(arguments);
      args = args.slice(1);
      return this.readUntil((function(x) {
        return args.some(function(v) {
          return x.current() === v;
        });
      }), withLast);
    };

    return CodeReader;

  })();

  SchemeDescription = (function() {

    function SchemeDescription(color, param) {
      this.color = color != null ? color : '#000000';
      this.param = param != null ? param : 'normal';
    }

    return SchemeDescription;

  })();

  Factory = (function() {

    function Factory() {
      this.data = [];
    }

    Factory.prototype.Register = function(code, item, title) {
      var p;
      if (title == null) {
        title = null;
      }
      p = {};
      p.code = code;
      p.item = item;
      if ((title != null)) {
        p.title = title;
      } else {
        p.title = code;
      }
      this.data.push(p);
      return true;
    };

    Factory.prototype.Find = function(code) {
      var p, _i, _len, _ref5;
      _ref5 = this.data;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        p = _ref5[_i];
        if (p.code === code) {
          return p.item;
        }
      }
      return null;
    };

    return Factory;

  })();

  Painter = (function() {

    Painter.prototype.settings = null;

    Painter.prototype.scheme = null;

    Painter.prototype.child = null;

    Painter.prototype.w = -1;

    Painter.prototype.h = -1;

    Painter.prototype.pT = 0;

    Painter.prototype.pB = 0;

    Painter.prototype.pL = 0;

    Painter.prototype.pR = 0;

    function Painter(canvas, settings, scheme) {
      this.settings = settings;
      this.scheme = scheme;
      this.ctx = canvas.getContext('2d');
    }

    Painter.prototype.withChild = function(child) {
      this.child = child;
      return this;
    };

    Painter.prototype.scheme = function() {
      return this.scheme;
    };

    Painter.prototype.measure = function() {
      var h, iH, iW, w, _ref5;
      w = 0;
      h = 0;
      if (this.w > 0) {
        w = this.w;
      }
      if (this.h > 0) {
        h = this.h;
      }
      if (this.child !== null) {
        _ref5 = this.child.measure(), iW = _ref5[0], iH = _ref5[1];
        if (w < iW) {
          w = iW;
        }
        h += iH;
      }
      w += this.pL + this.pR;
      h += this.pT + this.pB;
      return [w, h];
    };

    Painter.prototype.paint = function() {
      this.paintMe(0, 0);
      if ((this.child != null)) {
        this.child.paintMe(this.pL, this.pT);
      }
      return null;
    };

    Painter.prototype.paintMe = function(x, y) {
      return null;
    };

    return Painter;

  })();

  PainterFactoryController = (function(_super) {

    __extends(PainterFactoryController, _super);

    function PainterFactoryController() {
      PainterFactoryController.__super__.constructor.call(this);
      this.processParams = function(params) {
        var a, f, kv, p, s, _i, _len;
        a = params.trim().split(',');
        s = '{';
        f = true;
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          p = a[_i];
          kv = p.trim().split(':', 2);
          if (kv.length !== 2) {
            continue;
          }
          if (f) {
            f = false;
          } else {
            s += ',';
          }
          s += '"' + kv[0] + '":"' + kv[1] + '"';
        }
        s += '}';
        return s;
      };
    }

    PainterFactoryController.prototype.Create = function(canvas, initString, context, scheme) {
      var a, code, p, par;
      a = initString.split('=>', 2);
      if (a.length < 1) {
        return null;
      }
      code = a[0].trim().toLowerCase();
      p = this.Find(code);
      if (!(p != null)) {
        return null;
      }
      par = {};
      if (a.length > 1) {
        par = JSON.parse(this.processParams(a[1]));
      }
      return new p(canvas, par, context, scheme);
    };

    return PainterFactoryController;

  })(Factory);

  PainterFactory = new PainterFactoryController();

  PaintersBase = (function(_super) {

    __extends(PaintersBase, _super);

    function PaintersBase(canvas, params, settings, scheme) {
      this.params = params;
      PaintersBase.__super__.constructor.call(this, canvas, settings, scheme);
      this.initialize();
    }

    PaintersBase.prototype.get = function(key, defo) {
      var c;
      if (defo == null) {
        defo = null;
      }
      if ((this.params[key] != null)) {
        return this.params[key];
      }
      c = this.scheme.get(key);
      if ((c != null)) {
        return c.color;
      }
      return defo;
    };

    PaintersBase.prototype.setIfNull = function(key, val) {
      if (!(this.params[key] != null)) {
        this.params[key] = val;
      }
      return true;
    };

    PaintersBase.prototype.initialize = function() {
      return null;
    };

    return PaintersBase;

  })(Painter);

  ServicePainterBorder = (function(_super) {

    __extends(ServicePainterBorder, _super);

    function ServicePainterBorder() {
      return ServicePainterBorder.__super__.constructor.apply(this, arguments);
    }

    ServicePainterBorder.prototype.defRad = 5;

    ServicePainterBorder.prototype.defOffset = 1;

    ServicePainterBorder.prototype.initialize = function() {
      var r;
      this.setIfNull('radius', 0);
      this.setIfNull('width', 1);
      r = parseInt(this.get('radius'));
      if (r <= this.defRad) {
        r = this.defRad + this.defOffset;
      } else {
        r = r + this.defOffset;
      }
      this.pL = r;
      this.pT = r;
      this.pB = r;
      return this.pR = r;
    };

    ServicePainterBorder.prototype.paintMe = function(x, y) {
      var bg, cH, cW, o, o2, radius, x1, x2, y1, y2, _ref5;
      cW = 0;
      cH = 0;
      if ((this.child != null)) {
        _ref5 = this.child.measure(), cW = _ref5[0], cH = _ref5[1];
      }
      o = this.defOffset;
      o2 = 2 * this.defOffset;
      x1 = x + o;
      y1 = y + o;
      x2 = x + cW + this.pL + this.pR - o2;
      y2 = y + cH + this.pT + this.pB - o2;
      radius = parseInt(this.get('radius'));
      this.ctx.beginPath();
      this.ctx.moveTo(x1 + radius, y1);
      this.ctx.lineTo(x2 - radius, y1);
      this.ctx.quadraticCurveTo(x2, y1, x2, y1 + radius);
      this.ctx.lineTo(x2, y2 - radius);
      this.ctx.quadraticCurveTo(x2, y2, x2 - radius, y2);
      this.ctx.lineTo(x1 + radius, y2);
      this.ctx.quadraticCurveTo(x1, y2, x1, y2 - radius);
      this.ctx.lineTo(x1, y1 + radius);
      this.ctx.quadraticCurveTo(x1, y1, x1 + radius, y1);
      this.ctx.closePath();
      this.ctx.strokeStyle = this.get('fg', '#000000');
      this.ctx.lineWidth = parseInt(this.get('width'));
      this.ctx.stroke();
      bg = this.get('bg', 'transparent');
      if (bg !== 'transparent') {
        this.ctx.fillStyle = bg;
        this.ctx.fill();
      }
      return null;
    };

    return ServicePainterBorder;

  })(PaintersBase);

  PainterFactory.Register('border', ServicePainterBorder);

  CodePainter = (function(_super) {

    __extends(CodePainter, _super);

    function CodePainter(canvas, tokens, scheme, conf) {
      var _ref5;
      this.tokens = tokens;
      CodePainter.__super__.constructor.call(this, canvas, conf, scheme);
      _ref5 = this.calculate(), this.w = _ref5[0], this.h = _ref5[1];
    }

    CodePainter.prototype.withChild = function(child) {
      this.child = null;
      return this;
    };

    CodePainter.prototype.calculate = function() {
      var currH, currW, h, maxH, maxW, t, w, _i, _len, _ref5, _ref6;
      maxW = 0;
      maxH = 0;
      currH = 0;
      currW = 0;
      _ref5 = this.tokens;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        t = _ref5[_i];
        _ref6 = this.measureToken(t), w = _ref6[0], h = _ref6[1];
        currW += w;
        if (t instanceof TokenNewLine) {
          if (currH < h) {
            currH = h;
          }
          maxH += currH;
          if (maxW < currW) {
            maxW = currW;
          }
          currH = 0;
          currW = 0;
          continue;
        }
      }
      maxH += currH;
      if (maxW < currW) {
        maxW = currW;
      }
      if (maxW < this.settings.minWidth) {
        maxW = this.settings.minWidth;
      }
      return [maxW, maxH];
    };

    CodePainter.prototype.prepareContextForText = function(tokenCode) {
      var shDescription;
      shDescription = this.scheme.get('text-' + tokenCode);
      if (shDescription === null) {
        shDescription = this.scheme.get('text-normal');
      }
      if (shDescription === null) {
        shDescription = new SchemeDescription();
      }
      this.ctx.textBaseline = 'top';
      this.ctx.textAlign = 'left';
      this.ctx.font = shDescription.param + " " + this.scheme.size + "px " + this.scheme.font;
      this.ctx.fillStyle = shDescription.color;
      return this.scheme.size;
    };

    CodePainter.prototype.measureToken = function(t) {
      var c, dim, s;
      c = t.content;
      if (t instanceof TokenSpace) {
        c = " ";
      }
      s = this.prepareContextForText(t.code());
      dim = this.ctx.measureText(c);
      return [Math.round(dim.width), s];
    };

    CodePainter.prototype.drawToken = function(t, x, y) {
      var c, dim, s;
      c = t.content;
      if (t instanceof TokenSpace) {
        c = " ";
      }
      s = this.prepareContextForText(t.code());
      dim = this.ctx.measureText(c);
      this.ctx.fillText(c, x, y);
      return [Math.round(dim.width), s];
    };

    CodePainter.prototype.paintMe = function(x, y) {
      var cH, h, offX, offY, t, w, _i, _len, _ref5, _ref6;
      offX = x;
      offY = y;
      cH = 0;
      _ref5 = this.tokens;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        t = _ref5[_i];
        _ref6 = this.drawToken(t, offX, offY), w = _ref6[0], h = _ref6[1];
        if (cH < h) {
          cH = h;
        }
        offX += w;
        if (t instanceof TokenNewLine) {
          offX = x;
          offY += cH;
          continue;
        }
      }
      return null;
    };

    return CodePainter;

  })(Painter);

  ParserFactory = (function() {

    function ParserFactory() {}

    ParserFactory.parsers = [];

    ParserFactory.list = [];

    ParserFactory.Register = function(exts, parserName, title) {
      var ext, p, _i, _len;
      this.list.push({
        name: title,
        code: exts[0]
      });
      for (_i = 0, _len = exts.length; _i < _len; _i++) {
        ext = exts[_i];
        p = {};
        p.ext = ext.toLowerCase();
        p.parser = parserName;
        p.title = title;
        this.parsers.push(p);
      }
      return true;
    };

    ParserFactory.findParser = function(extension) {
      var ext, p, _i, _len, _ref5;
      ext = extension.toLowerCase();
      _ref5 = this.parsers;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        p = _ref5[_i];
        if (p.ext === ext) {
          return p.parser;
        }
      }
      return null;
    };

    ParserFactory.makePrintable = function(arr) {
      arr.Print = function() {
        var s, t, _i, _len;
        s = '';
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          t = this[_i];
          s += t.toStr() + "\r\n";
        }
        return s;
      };
      return arr;
    };

    ParserFactory.List = function() {
      return this.list;
    };

    ParserFactory.Parse = function(ext, text) {
      var c, p;
      c = new CodeReader(text);
      p = ParserFactory.findParser(ext);
      if (p === null) {
        return null;
      }
      p = new p();
      p.init();
      return ParserFactory.makePrintable(p.tokenize(c));
    };

    return ParserFactory;

  })();

  Scheme = (function() {

    Scheme.prototype.colors = new Object();

    function Scheme(font, size) {
      this.font = font;
      this.size = size;
    }

    Scheme.prototype.get = function(key) {
      if ((this.colors[key] != null)) {
        return this.colors[key];
      }
      return null;
    };

    Scheme.prototype.set = function(key, description) {
      this.colors[key] = description;
      return this;
    };

    return Scheme;

  })();

  SchemeFactoryController = (function(_super) {

    __extends(SchemeFactoryController, _super);

    function SchemeFactoryController() {
      return SchemeFactoryController.__super__.constructor.apply(this, arguments);
    }

    SchemeFactoryController.prototype.Create = function(code, font, size) {
      var s;
      if (font == null) {
        font = 'Courier New';
      }
      if (size == null) {
        size = 13;
      }
      s = this.Find(code);
      return new s(font, size);
    };

    SchemeFactoryController.prototype.List = function() {
      var a, p, _i, _len, _ref5;
      a = [];
      _ref5 = this.data;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        p = _ref5[_i];
        a.push({
          code: p.code,
          name: p.title
        });
      }
      return a;
    };

    return SchemeFactoryController;

  })(Factory);

  SchemeFactory = new SchemeFactoryController();

  AptanaSch = (function(_super) {

    __extends(AptanaSch, _super);

    function AptanaSch(font, size) {
      this.font = font;
      this.size = size;
      this.set('text-normal', new SchemeDescription('#9b6f46'));
      this.set('text-keyword', new SchemeDescription('#cda772'));
      this.set('text-outlined', new SchemeDescription('#7187a3'));
      this.set('text-string', new SchemeDescription('#8f9d69'));
      this.set('text-comment', new SchemeDescription('#615e64'));
      this.set('text-directive', new SchemeDescription('#c86952', 'bold'));
      this.set('text-specialSymbol', new SchemeDescription('#c86952', 'bold'));
      this.set('bg', new SchemeDescription('#141414', 'solid'));
      AptanaSch.__super__.constructor.call(this, this.font, this.size);
    }

    return AptanaSch;

  })(Scheme);

  SchemeFactory.Register('aptana', AptanaSch, 'Aptana');

  VisualStudioTenSch = (function(_super) {

    __extends(VisualStudioTenSch, _super);

    function VisualStudioTenSch(font, size) {
      this.font = font;
      this.size = size;
      this.set('text-normal', new SchemeDescription());
      this.set('text-keyword', new SchemeDescription('#0000FF'));
      this.set('text-outlined', new SchemeDescription('#008080'));
      this.set('text-string', new SchemeDescription('#800000'));
      this.set('text-comment', new SchemeDescription('#008000'));
      this.set('text-directive', new SchemeDescription('#000080', 'bold'));
      this.set('text-specialSymbol', new SchemeDescription('#000000', 'bold'));
      this.set('bg', new SchemeDescription('#FFFFFF', 'solid'));
      VisualStudioTenSch.__super__.constructor.call(this, this.font, this.size);
    }

    return VisualStudioTenSch;

  })(Scheme);

  SchemeFactory.Register('vs2010', VisualStudioTenSch, 'VS 2010');

  SyntaxParser = (function() {

    function SyntaxParser() {
      this.outlinedWords = [];
      this.analyzers = [];
      this.keywords = [];
      this.registerAnalyzer = function(analyzer) {
        return this.analyzers.push(analyzer);
      };
      this.registerAnalyzers = function(analyzers) {
        var analyzer, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = analyzers.length; _i < _len; _i++) {
          analyzer = analyzers[_i];
          _results.push(this.registerAnalyzer(analyzer));
        }
        return _results;
      };
      this.registerKeyword = function(keyword) {
        return this.keywords.push(keyword);
      };
      this.registerKeywords = function(keywords) {
        var keyword, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = keywords.length; _i < _len; _i++) {
          keyword = keywords[_i];
          _results.push(this.registerKeyword(keyword));
        }
        return _results;
      };
      this.registerOutlinedWord = function(word) {
        return this.outlinedWords.push(word);
      };
      this.registerOutlinedWords = function(words) {
        var word, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = words.length; _i < _len; _i++) {
          word = words[_i];
          _results.push(this.registerOutlinedWord(word));
        }
        return _results;
      };
      this.beforeTokenFlush = function(tokens, token) {
        var content;
        if (token instanceof TokenUndefined) {
          content = token.content;
          if (this.keywords.some(function(x) {
            return content === x;
          })) {
            return new TokenKeyword(content);
          }
          if (this.outlinedWords.some(function(x) {
            return x === content;
          })) {
            return new TokenOutlined(content);
          } else {
            return new TokenNormal(content);
          }
        } else {
          return token;
        }
      };
    }

    SyntaxParser.prototype.init = function() {
      this.registerAnalyzer(new NewLineAnalyzer());
      this.registerAnalyzer(new SpaceAnalyzer());
      this.registerAnalyzer(new PaddingAnalyzer());
      return this.registerAnalyzer(new StringAnalyzer());
    };

    SyntaxParser.prototype.tokenize = function(reader) {
      var flusher, temporary, tokens,
        _this = this;
      tokens = new Array();
      flusher = function(token) {
        if (token === null) {
          return;
        }
        token = _this.beforeTokenFlush(tokens, token);
        return tokens.push(token);
      };
      temporary = null;
      temporary = this.analyzeState(temporary, reader, tokens, flusher);
      while (reader.readNext()) {
        temporary = this.analyzeState(temporary, reader, tokens, flusher);
      }
      flusher(temporary);
      if (tokens.length > 0 && !(tokens[tokens.length - 1] instanceof TokenNewLine)) {
        tokens.push(new TokenNewLine());
      }
      return tokens;
    };

    SyntaxParser.prototype.analyzeState = function(temporary, reader, tokens, flusher) {
      var analyzer, _i, _len, _ref5;
      _ref5 = this.analyzers;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        analyzer = _ref5[_i];
        if (!analyzer.match(reader, temporary, tokens)) {
          continue;
        }
        temporary = analyzer.performAction(temporary, reader, tokens, flusher);
        if (temporary == null) {
          temporary = null;
        }
        return temporary;
      }
      if (temporary == null) {
        temporary = new TokenUndefined();
      }
      temporary.addChar(reader.current());
      return temporary;
    };

    return SyntaxParser;

  })();

  CoffeeScriptParser = (function(_super) {

    __extends(CoffeeScriptParser, _super);

    function CoffeeScriptParser() {
      return CoffeeScriptParser.__super__.constructor.apply(this, arguments);
    }

    CoffeeScriptParser.prototype.init = function() {
      CoffeeScriptParser.__super__.init.call(this);
      this.registerAnalyzers([new UnixCommentAnalyzer(), new DelimiterAnalyzer()]);
      return this.registerKeywords(["if", "then", "else", "unless", "and", "new", "return", "try", "catch", "finally", "throw", "or", "is", "isnt", "not", "break", "continue", "by", "of", "where", "when", "until", "for", "in", "while", "delete", "instanceof", "typeof", "switch", "super", "extends", "class", "case", "default", "do", "function", "with", "const", "let", "debugger", "enum", "export", "import", "native", "__extends", "__hasProp"]);
    };

    return CoffeeScriptParser;

  })(SyntaxParser);

  ParserFactory.Register(['coffee', 'coffeescript'], CoffeeScriptParser, "Coffee Script");

  SharpDirectiveAnalyzer = (function(_super) {

    __extends(SharpDirectiveAnalyzer, _super);

    function SharpDirectiveAnalyzer() {
      return SharpDirectiveAnalyzer.__super__.constructor.apply(this, arguments);
    }

    SharpDirectiveAnalyzer.prototype.match = function(reader, temporaryToken, tokens) {
      return temporaryToken === null && reader.current() === '#';
    };

    SharpDirectiveAnalyzer.prototype.performAction = function(temporaryToken, reader, tokens, flush) {
      reader.readUntilCharsLast(false, "\r", "\n");
      flush(new TokenSharpDirective("#" + reader.buffer));
      return temporaryToken;
    };

    return SharpDirectiveAnalyzer;

  })(Analyzer);

  CSharpParser = (function(_super) {

    __extends(CSharpParser, _super);

    function CSharpParser() {
      return CSharpParser.__super__.constructor.apply(this, arguments);
    }

    CSharpParser.prototype.init = function() {
      CSharpParser.__super__.init.call(this);
      this.registerAnalyzers([new CppCommentAnalyzer(), new CppCommentPlusAnalyzer(), new SharpDirectiveAnalyzer(), new DelimiterAnalyzer()]);
      this.registerKeywords(["abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "var", "virtual", "void", "volatile", "while"]);
      return this.registerOutlinedWords(["String", "Boolean", "Int32", "Int16", "Int64", "Double", "StringBuilder", "Object", "KeyValuePair", "List", "Array", "Dictionary", "HashSet"]);
    };

    return CSharpParser;

  })(SyntaxParser);

  ParserFactory.Register(['cs', 'csharp', 'c#'], CSharpParser, "C#");

  JavaParser = (function(_super) {

    __extends(JavaParser, _super);

    function JavaParser() {
      return JavaParser.__super__.constructor.apply(this, arguments);
    }

    JavaParser.prototype.init = function() {
      JavaParser.__super__.init.call(this);
      this.registerAnalyzers([new CppCommentAnalyzer(), new CppCommentPlusAnalyzer(), new DelimiterAnalyzer()]);
      this.registerKeywords(["abstract", "assert", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "default", "do", "double", "else", "enum", "extends", "final", "finally", "float", "for", "goto", "if", "implements", "import", "instanceof", "int", "interface", "internal", "is", "long", "native", "new", "package", "private", "protected", "public", "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "try", "void", "volatile", "while"]);
      return this.registerOutlinedWords(["string", "int", "object"]);
    };

    return JavaParser;

  })(SyntaxParser);

  ParserFactory.Register(['java'], JavaParser, "Java");

  RubyParser = (function(_super) {

    __extends(RubyParser, _super);

    function RubyParser() {
      return RubyParser.__super__.constructor.apply(this, arguments);
    }

    RubyParser.prototype.init = function() {
      RubyParser.__super__.init.call(this);
      this.registerAnalyzers([new UnixCommentAnalyzer(), new DelimiterAnalyzer()]);
      this.registerKeywords(["BEGIN", "END", "alias", "and", "begin", "break", "case", "class", "def", "defined", "do", "else", "elsif", "end", "ensure", "false", "for", "if", "module", "next", "nil", "not", "or", "redo", "rescue", "retry", "return", "self", "super", "private", "then", "true", "undef", "unless", "until", "when", "while", "yield", "__FILE__", "__LINE__"]);
      return this.registerOutlinedWords(["print"]);
    };

    return RubyParser;

  })(SyntaxParser);

  ParserFactory.Register(['rb', 'ruby'], RubyParser, "Ruby");

  SyntaxToken = (function() {

    function SyntaxToken(type, content) {
      this.type = type != null ? type : '(null)';
      this.content = content != null ? content : '';
    }

    SyntaxToken.prototype.code = function() {
      return this.type;
    };

    SyntaxToken.prototype.addChar = function(chr) {
      return this.content += chr;
    };

    SyntaxToken.prototype.toStr = function() {
      return this.type.toString() + ': ' + this.content.toString();
    };

    return SyntaxToken;

  })();

  TokenUndefined = (function(_super) {

    __extends(TokenUndefined, _super);

    function TokenUndefined(content) {
      this.content = content != null ? content : '';
      TokenUndefined.__super__.constructor.call(this, 'undefined', this.content);
    }

    return TokenUndefined;

  })(SyntaxToken);

  TokenSpace = (function(_super) {

    __extends(TokenSpace, _super);

    function TokenSpace(content) {
      this.content = content != null ? content : '';
      TokenSpace.__super__.constructor.call(this, 'space', this.content);
    }

    return TokenSpace;

  })(SyntaxToken);

  TokenNewLine = (function(_super) {

    __extends(TokenNewLine, _super);

    function TokenNewLine(content) {
      this.content = content != null ? content : '';
      TokenNewLine.__super__.constructor.call(this, 'new-line', this.content);
    }

    return TokenNewLine;

  })(SyntaxToken);

  TokenDelimiter = (function(_super) {

    __extends(TokenDelimiter, _super);

    function TokenDelimiter(content) {
      this.content = content != null ? content : '';
      TokenDelimiter.__super__.constructor.call(this, 'delimiter', this.content);
    }

    return TokenDelimiter;

  })(SyntaxToken);

  TokenComment = (function(_super) {

    __extends(TokenComment, _super);

    function TokenComment(content) {
      this.content = content != null ? content : '';
      TokenComment.__super__.constructor.call(this, 'comment', this.content);
    }

    return TokenComment;

  })(SyntaxToken);

  TokenPadding = (function(_super) {

    __extends(TokenPadding, _super);

    function TokenPadding(content) {
      this.content = content != null ? content : '';
      TokenPadding.__super__.constructor.call(this, 'padding', this.content);
    }

    return TokenPadding;

  })(SyntaxToken);

  TokenString = (function(_super) {

    __extends(TokenString, _super);

    function TokenString(content) {
      this.content = content != null ? content : '';
      TokenString.__super__.constructor.call(this, 'string', this.content);
    }

    return TokenString;

  })(SyntaxToken);

  TokenKeyword = (function(_super) {

    __extends(TokenKeyword, _super);

    function TokenKeyword(content) {
      this.content = content != null ? content : '';
      TokenKeyword.__super__.constructor.call(this, 'keyword', this.content);
    }

    return TokenKeyword;

  })(SyntaxToken);

  TokenNormal = (function(_super) {

    __extends(TokenNormal, _super);

    function TokenNormal(content) {
      this.content = content != null ? content : '';
      TokenNormal.__super__.constructor.call(this, 'normal', this.content);
    }

    return TokenNormal;

  })(SyntaxToken);

  TokenOutlined = (function(_super) {

    __extends(TokenOutlined, _super);

    function TokenOutlined(content) {
      this.content = content != null ? content : '';
      TokenOutlined.__super__.constructor.call(this, 'outlined', this.content);
    }

    return TokenOutlined;

  })(SyntaxToken);

  TokenSharpDirective = (function(_super) {

    __extends(TokenSharpDirective, _super);

    function TokenSharpDirective(content) {
      this.content = content != null ? content : '';
      TokenSharpDirective.__super__.constructor.call(this, 'directive', this.content);
    }

    return TokenSharpDirective;

  })(SyntaxToken);

  SnipController = (function() {

    function SnipController() {
      this.transform = function(ext, text, scheme, painters, context) {
        var c, cont, dbg, h, p, ps, sh, tokens, tp, w, _i, _len, _ref5;
        if (painters == null) {
          painters = [];
        }
        if (context == null) {
          context = null;
        }
        cont = context;
        if (!(cont != null)) {
          cont = this.mergeSettings(cont);
        }
        tokens = ParserFactory.Parse(ext, text);
        if (tokens === null) {
          console.log("snip2me: extension `" + ext + "` is not supported");
          return null;
        }
        dbg = document.getElementById('pre4debug');
        if ((dbg != null)) {
          dbg.innerHTML = tokens.Print();
        }
        c = document.createElement("canvas");
        sh = SchemeFactory.Create(scheme, context.font, context.size);
        p = new CodePainter(c, tokens, sh, cont);
        for (_i = 0, _len = painters.length; _i < _len; _i++) {
          ps = painters[_i];
          tp = PainterFactory.Create(c, ps, cont, sh);
          if (!(tp != null)) {
            break;
          }
          tp.withChild(p);
          p = tp;
        }
        _ref5 = p.measure(), w = _ref5[0], h = _ref5[1];
        c.width = w;
        c.height = h;
        p.paint();
        return c.toDataURL();
      };
      this.getPaintersFromElement = function(el) {
        var a, arr, attr, code, r, v, _i, _j, _len, _len1, _ref5;
        code = 'data-snip-painter-';
        arr = [];
        _ref5 = el.attributes;
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          attr = _ref5[_i];
          if (attr.name.indexOf(code) !== 0) {
            continue;
          }
          v = {};
          v.num = parseInt(attr.name.substring(code.length));
          v.val = attr.value;
          arr.push(v);
        }
        arr.sort(function(a, b) {
          return b.num - a.num;
        });
        r = [];
        for (_j = 0, _len1 = arr.length; _j < _len1; _j++) {
          a = arr[_j];
          r.push(a.val);
        }
        return r;
      };
      this.transformElement = function(el) {
        var ext, gist, painters, sch;
        ext = el.getAttribute('data-snip-lang');
        sch = el.getAttribute('data-snip-scheme');
        gist = el.getAttribute('data-snip-gist');
        painters = this.getPaintersFromElement(el);
        if (!(gist != null)) {
          return this.transformNonGist(el, ext, sch, painters);
        } else {
          return this.transformGist(el, ext, sch, gist, painters);
        }
      };
      this.transformNonGist = function(elem, ext, sch, painters) {
        var img, uri;
        uri = this.transform(ext, elem.childNodes[0].nodeValue, sch, painters, this.readConfFromElement(elem));
        if (uri === null) {
          return false;
        }
        img = uri.toImg();
        elem.parentNode.replaceChild(img, elem);
        return true;
      };
      this.transformGist = function(el, ext, sch, gist, painters) {
        return false;
      };
      this.findAllElements = function(attribute) {
        var allElements, elem, matchingElements, _i, _len;
        matchingElements = [];
        allElements = document.getElementsByTagName('*');
        for (_i = 0, _len = allElements.length; _i < _len; _i++) {
          elem = allElements[_i];
          if ((elem.getAttribute(attribute) != null)) {
            matchingElements.push(elem);
          }
        }
        return matchingElements;
      };
      this.defaults = {
        minWidth: 0,
        font: 'Courier New',
        size: 12
      };
      this.readConfFromElement = function(el) {
        var attr, code, obj, _i, _len, _ref5;
        code = 'data-snip-conf-';
        obj = {};
        _ref5 = el.attributes;
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          attr = _ref5[_i];
          if (attr.name.indexOf(code) !== 0) {
            continue;
          }
          obj[attr.name.substring(code.length).dashToCamel()] = attr.value;
        }
        return this.mergeSettings(obj);
      };
      this.mergeSettings = function(obj) {
        return this.mergeObjs(this.defaults, obj);
      };
      this.isInt = function(n) {
        return typeof n === 'number' && n % 1 === 0;
      };
      this.mergeObjs = function(obj1, obj2) {
        var obj3, p, v, _i, _len, _ref5;
        obj3 = {};
        _ref5 = Object.keys(obj1);
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          p = _ref5[_i];
          v = null;
          try {
            if (obj1[p].constructor === Object) {
              v = this.mergeObjs(obj1[p], obj2[p]);
            } else {
              if ((obj2 != null) && (obj2[p] != null)) {
                v = obj2[p];
              } else {
                v = obj1[p];
              }
            }
          } catch (error) {
            v = obj1[p];
          }
          if (this.isInt(obj1[p])) {
            obj3[p] = parseInt(v);
          } else {
            obj3[p] = v;
          }
        }
        return obj3;
      };
      this.isElement = function(o) {
        if ((typeof HTMLElement) === "object") {
          return o instanceof HTMLElement;
        }
        return o && (typeof o) === "object" && o.nodeType === 1 && (typeof o.nodeName) === "string";
      };
      this.canRun = false;
      this.runChecked = false;
      this.checkVersions = function(browser, version) {
        switch (browser) {
          case "opera":
            return version >= 12.1;
          case "chrome":
            return version >= 22.0;
          case "safari":
            return version >= 5.1;
          case "firefox":
            return version >= 15.0;
          case "msie":
            return version >= 9.0;
          default:
            return true;
        }
      };
    }

    SnipController.prototype.me = function() {
      var e, elems, _i, _len;
      if (!this.isCompatible()) {
        return false;
      }
      elems = this.findAllElements('data-snip-lang');
      for (_i = 0, _len = elems.length; _i < _len; _i++) {
        e = elems[_i];
        this.transformElement(e);
      }
      return true;
    };

    SnipController.prototype.compile = function(element) {
      if (!this.isCompatible()) {
        return false;
      }
      if (this.isElement(element)) {
        return this.transformElement(element);
      } else {
        return this.transform.apply(snip2, arguments);
      }
    };

    SnipController.prototype.setSettings = function(settings) {
      return this.defaults = this.mergeSettings(settings);
    };

    SnipController.prototype.isCompatible = function() {
      var M, N, tem, ua;
      if (this.runChecked) {
        return this.canRun;
      }
      this.runChecked = true;
      N = navigator.appName;
      ua = navigator.userAgent;
      tem = null;
      M = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
      if (M && (tem = ua.match(/version\/([\.\d]+)/i)) !== null) {
        M[2] = tem[1];
      }
      if ((M != null)) {
        M = [M[1], M[2]];
      } else {
        M = [N, navigator.appVersion, '-?'];
      }
      this.canRun = this.checkVersions(M[0].toLowerCase(), parseFloat(M[1]));
      if (!this.canRun) {
        console.log("snip2me is not compatible with current browser");
      }
      return this.canRun;
    };

    SnipController.prototype.parsers = function() {
      return ParserFactory.List();
    };

    SnipController.prototype.schemes = function() {
      return SchemeFactory.List();
    };

    return SnipController;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.snip2 = new SnipController();

  autoLoader = function() {
    if ((root.snip != null)) {
      root.snip2.setSettings.apply(root.snip2, [root.snip]);
    }
    return root.snip2.me.apply(root.snip2);
  };

  if (window.addEventListener) {
    window.addEventListener("load", autoLoader, false);
  } else {
    window.attachEvent("onload", autoLoader);
  }

}).call(this);
